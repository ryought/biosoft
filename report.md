# 1 sortingの演習課題
## 1.1 randomized quicksort
### 帰納法による証明
#### 全体について
P(n):長さnの配列がソートされるということ
(1) n=1の時、すでにソート済み
(2) n=1~kでP(n)とする。この時、partitionアルゴリズムにより(A:pivotより小さい)(pivot)(B:pivotより大きい)の3区間に分かれ、pivotは少なくとも1つあるので、AとBはnより小さい。だからP(|A|)またP(|B|)だから、ソート可能である。


#### partitionについて
P(n):長さnの配列がpartitionによって区分できる
(1) P(1)は成立。なぜならpivot選んだ時点で完成しているから
(2) P(k)を仮定する。つまり長さkの配列(pivot除いてk-1個)のpartitionは可能と仮定する。
長さk+1の配列を用意する。pivotを選んで、残りk個について考える。
左側から1つ要素xをとったとする。
(i)もしxがpivotより小さい時、xはそのまま左側に置いておいて、残りのk-1個についてpartitionの作業をすれば良い
(ii)もしxがpivotより大きい時、xは右端の要素と交換し、残りの(左端から右端-1までの)k-1個の要素についてpartitionを行えば良い。

従ってこれを繰り返せばpartitionが全域で完了することになる。


### partitionの変形
`for(;;){`で始まるループ(以下A)の中に、`for(i++; target...)`と`for(j--; pivot...)`のループ(以下B)が入っている構造になっている。
#### 1
`int i = left` `int j = right-1`に変形した時
最初の一回のループで始まる位置が一つずれてしまうから、target[left]とtarget[right]の値は検査されない。なので、両端にソート済みの値(つまり最小値最大値)がある時は正常に動くが、それ以外の時は正常に動かない。

#### 2
ループBの`i++` `j--`を消した時

最初の一回はi,jの中身は正しい状態と同じであるが、ループAの2回目以降、ループBに入る時にi,jの値がインクリメント・デクリメントされないことになる。
たとえばもし`target[i]==target[j]==pivot`となった時は、ループBは更新条件を満たさないため通過し、両者を交換するという作業を無限に繰り返すことになる。無限ループに陥るので、処理が終了しないことになってしまう。(もし`i++, j--`があれば、交換した直後にその値を再評価することはないので、同じ値があっても無限ループにはならない。)



## 1.2 multiply(a,b)とtarai(x,y,z)
それぞれの呼び出しについて、stackoverflowする入力は何か。

multiplyは、multiply(a,b)の値が出るまでにa回multiplyが呼び出される。スタックサイズに依存するが、aを大きい値(一回の関数呼び出しのスタック消費量*a が全体のスタック量を超えるような値)にすればオーバーフローする。
手元の環境では、a=20000では動作するがa=30000では動作しなかった。

taraiについて、再帰呼び出しが多くなるような引数を与えれば、関数のスタックをたくさん積ませることでsegmentation faultさせられる。例えば(100000, 1, 1)など。


## 1.3 randomized quicksortの改良
各クイックソートの関数は`sort.h`内のrandomQuickSortK K=1,2,3...である。
速度の評価を行うために、ベンチマークプログラムを用意した。
10回処理を行い、その平均を(bench.shによって)計算した。

SIZE = 100000 = 10^5の時
1 31906
2 31627
3 30909
4 18013(minsize = 10)
5 16732

SIZE = 1000000 = 10^6の時
1 297551
2 294694
3 305497
4 181150(minsize = 10)
5 160812

SIZEを10倍にすると処理時間も10倍になっているので、O(n)であることが予想できる。


## 1.4 ternary split quick sortの実装
`sort.h`内のternarySplitQuickSortである。

## 1.5 Radix SortのMSDからソートする版の実装
`sort.h`内のradixSortMSDである。

`radixSortSub(int* target, int left, int right, int digit)`は、整数の配列targetのうちleftからright番目の要素を、digit桁目以降についてradixsortする関数である。
ある桁数についてソートが終わると、そのうちその桁の数が同じ部分に関して、一つ下の桁に注目してソート（同じ関数を再帰呼び出し）するように動いている。


## 1.6 オプション
Randomized Quick Sortを変形した、平均計算量がO(n)となるアルゴリズムと、median of mediansの考え方による、最悪計算量がO(n)となるアルゴリズムの両方を実装した(`select.h`内)。
実行時間は、N=100000のランダムな数字を並べた配列に対して実行することで測定した。結果はselectAveが2447us、selectWorstが10674usであった。

